# 대외계 개발 후기

캄보디아에서 진행한 은행 프로젝트에서 대외계 개발을 했다. 통합 테스트를 통과했고 이제 오픈일정에 맞춰 엔드포인트를 바꾸는 이행 작업만 남은 상태이다. 까먹기 전에 개발 경험과 지식을 짧게나마 기록해보려고 한다.

## 배경

이번 프로젝트에서는 3개의 방식으로 이체거래가 가능했다. 3개 모두 캄보디아 중앙은행인 NBC(National Bank of Cambodia)에서 제공하는 방식이었다.

1. RFT: 한국의 KOICA가 NBC와 협력하여 2016년 경 구축한 지급결제시스템. 한국에서 사용하는 타행환 공동망 시스템과 매우 유사한 시스템이다.
2. FAST: NBC가 2016년 경 자체적으로 구축한 첫 지급결제시스템.
3. BAKONG: NBC가 2019년 경 자체적으로 구축한 최신 지급결제시스템. 가장 거래량이 많고 NBC에서 계속해서 업그레이드하고 있는 시스템. FAST와 인터페이스 등이 거의 대부분 호환되고 개발 측면에서도 거의 동일하다. [하지만 내부적으로 블록체인 기술을 사용하고 있고, 모바일 결제 시스템과 연동되어있다.](https://bakong.nbc.gov.kh/download/NBC_BAKONG_White_Paper.pdf)

[RFT와 FAST에 관한 KOICA 자료](https://www.oda.go.kr/opo/cmcd/comm/downloadFile.do?P_STRE_FILE_NM=DE661558-F5F9-5A30-0EFD-E8B698D22187.pdf)

3가지 방식 모두 일반적으로 공유하고 있는 지급결제 절차가 있다.

1. outgoing: 송금측은 먼저 수신측의 계좌 정보를 확인하는 요청을 보낸다. 계좌 정보가 유효하다면 이름을 확인하고 송금 요청을 보낸다.
2. incoming: 수신측은 수신 관련 데이터를 받고 이체 처리에 성공하면 성공 응답을 실패하면 실패 응답을 보낸다.

## 문서를 읽고 흐름 파악하기

일반적인 절차가 있기는 하지만 실제로 내부를 들여다보면 각 방식에 따라 추가적으로 파악해야하는 흐름들이 있다. 특히 지급결제에서는 한 주체가 송금자가 될 수도 수신자가 될 수도 있다. 따라서 결제가 일어나는 흐름을 총체적으로 파악하는 것이 큰 도움이 된다. 또한 그 흐름은 한 주체 뿐만 아니라 모든 주체에게 동일하게 적용되는 것이기 때문에 문서를 잘 읽고 문서의 요구사항에 맞춰 개발하는 것이 매우 중요하다.

### RFT의 특이한 프로세스

RFT에는 특이하게 휴대폰 번호로 현금을 인출할 수 있는 지급결제 시스템이 있었다. a라는 사람이 A은행에서 금액과 받는 사람의 이름, 휴대폰 번호 등을 제출하면 A은행은 passcode를 발급한다. 그러면 b라는 사람이 자신의 휴대폰 번호와 a로부터 전달받은 passcode를 B은행에 제출하여 설정된 금액만큼을 인출할 수 있는 시스템이다. 이런 시스템이 왜 필요했는지는 잘 감이 안온다. 계좌가 없는 사람에게 돈을 보내고자 한 것이 아니었을까 싶다.

어쨋든, 이 시스템에서 특이한 점은 송금자가 원할 때 돈을 보내는 것이 아니라 수신자가 원할 때 돈을 보낸다는 점이었다. 그리고 이것이 처리되는 과정도 다소 특이했다. 수신측 은행은 송금측 은행에게 passcode 확인을 요청한다. 그러면 송금측 은행은 passcode가 유효한 passcode인지 아닌지를 응답한다. 언뜻 생각하면 passcode가 유효하다는 응답이 왔을 때 수신측에서 이체 처리를 하고 현금을 지급하면 될 것같다. 하지만 실제로는 그러한 방식이 아니었다. 수신측의 passcode 확인 관련 요청과 응답이 끝난 후, RFT CM 모듈에서 자동으로 송금을 위한 요청을 만들어서 수신측에 전달하고, 수신측은 이 요청을 받았을 때 비로소 이체 처리를 해야하는 방식이었다. 즉 수신측은 passcode가 유효하다는 응답을 받고도 송신측에게 요청을 받을 때까지 기다린 후 현금을 지급해야하는 것이었다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/financial-it-system-metadata/master/img/20231231-rft-passcode.png" alt="RFT passcode" maxWidth="700"/>
</div>

이런 처리 방식은 문서를 꼼꼼히 읽지 않으면 파악하기 힘들다. 실제로 RFT 개발에 참여한 대부분의 사람들이 passcode가 유효하다는 응답이 오면 바로 이체처리를 하는 것으로 착각하고 있었다. 대외계는 반드시 따라야하는 스펙이 있는 만큼 처음부터 문서를 꼼꼼히 읽고 흐름을 제대로 파악하는 것이 매우 중요하는 것을 배웠다.

### FAST/BAKONG의 비동기적인 이체처리

RFT의 경우 HTTP로 송금 요청을 보내면 송금이 성공했는지 실패했는지 HTTP 응답으로써 알 수 있다. 하지만 FAST/BAKONG은 그렇지 않았다. 송금 요청을 보내면 NBC에서 단순히 요청을 잘 받았다는 ACSP 상태를 반환한다. 그리고 상대방이 이체처리를 하고 NBC에 이체를 성공적으로 마무리했다는 것을 전달한 후에 비로소 이체가 성공적으로 처리되었다는 ASAC 상태가 된다. 만약 상대방이 이체처리에 실패하여 거래를 되돌리고 싶으면 NBC에 reversal 요청을 보내고, NBC는 이 reversal 요청을 별도의 incoming 거래로 변환하여, 송금측의 이체 처리를 보상하게 된다. 이러한 흐름은 결국 문서를 보고 파악 할 수 밖에 없다. 관련 문서를 총 동원하여 차근차근 읽어보고 이해가 안되는 부분은 퍼즐 맞추기 하듯 필요한 내용을 찾아보면서 이해해나갈 수밖에 없다. ~~이 때 최신 문서인지 반드시 확인해야 한다. 초기 버전의 문서를 보는 바람에 등줄기가 서늘했던 적이 있다...~~

## incoming 거래를 처리하는 방식

### RFT의 incoming: 요청을 받아 동기적인 응답

RFT는 중앙기관이 수신측 은행에 직접 요청을 보낸다. 수신측은 요청을 받아 이체 처리를 하고 그 결과를 응답한다. 이 방식의 개발은 컨트롤러-서비스-레포지토리 계층에 따라 이루어졌다. 중앙기관이 컨트롤러를 제공하고, 그 컨트롤러가 호출하는 서비스를 명시한다. 수신측 은행은 코어뱅킹(레포지토리)과 소통하는 서비스를 개발하면 된다. 프로젝트를 할 때는 주로 컨트롤러-서비스-레포지토리 전부를 하나의 주체가 개발하는 경우가 많았다. 하지만 이번 개발의 경우 컨트롤러는 중앙기관이 제공한 스펙을 따르고, 레포지토리는 코어뱅킹 솔루션의 API를 사용하여 서비스를 개발했다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/financial-it-system-metadata/master/img/20231231-rft-incoming-layers.png" alt="RFT layered architecture" maxWidth="700"/>
</div>

### FAST/BAKONG의 incoming: 요청을 하여 데이터를 받아 처리

FAST와 BAKONG은 incoming 거래를 처리하는 방식이 RFT와는 달랐다. 중앙기관이 요청을 보내는 것이 아니었다. 수신측이 중앙기관에 수신 목록을 요청하여 처리하는 방식이었다. 스케줄 작업을 통해 일정한 주기로 중앙기관에 수신 목록을 요청하고, 수신한 것이 있다면 처리하여 중앙기관에 수신 처리가 되었음을 별도의 요청으로 알려주는 방식이었다. 이 방식에서 좀 더 신경을 썼던 것은, `double-spending 문제`였다.

BAKONG의 경우 1초에 한 번씩 스케줄 작업이 돌도록 설정되어있었다. 그런데 만약 t초에 시작된 스케줄 작업이 끝나기 전에 t+1초의 스케줄 작업이 시작되어버리면 같은 수신에 대해서 2번 이체 처리를 할 가능성이 있었다. 따라서 앞 선 스케줄 작업이 끝나지 않았다면 다음 스케줄 작업을 시작하지 않도록 상태값을 통해서 제어했다. 또한 코어뱅킹 API에서 외부에서 unique reference number를 설정하도록 하였기 때문에 하나의 수신에 1대 1로 대응하는 값을 코어뱅킹의 unique reference number로 설정하여주었다. 이렇게 하면 같은 unique reference number가 들어올시 코어뱅킹 쪽에서 중복 에러를 발생시키기 때문에 보다 신뢰할 수 있었다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/financial-it-system-metadata/master/img/20231231-fast-incoming.png" alt="FAST incoming" maxWidth="700"/>
</div>

## 이체 거래시 내부 회계 처리와 청산

코어뱅킹 API에서 이체처리를 할 때는 항상 돈을 받는 사람(creditor)과 돈을 주는 사람(debtor) 두 측을 명시하도록 되어있었다. 하지만 외부에서 돈이 이체된 경우는 어떻게 처리해야 할까? incoming 거래라고 한다면 돈을 받는 계좌는 우리 은행에 있으니 그쪽 계좌로 돈을 넣어주면 된다. 하지만 돈을 보내는 사람은 우리 쪽에 있는 계좌가 아니다.

이 때 General Ledger(GL)라고 불리는 계정을 사용하게 된다. 일반적으로 GL은 복식부기로 거래를 기록한 장부를 말하는데 개발하는 입장에서는 '특수한 계좌' 정도로 이해해도 큰 무리는 없다. 그럼에도 GL이라는 용어를 쓰는 것은 외부로 돈이 나가거나 들어오는 것은 은행의 재무제표에 영향을 주기 때문이다. 돈이 나가는 것은 현금을 줄이고, 동시에 은행의 부채도 줄이게 된다. 반대로 돈이 들어오는 것은 현금을 늘리고, 은행의 부채를 늘린다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/financial-it-system-metadata/master/img/20231231-money-transfer.png" alt="money transfer" maxWidth="700"/>
</div>

그런데 사실 은행 간에 실시간으로 돈을 주고 받지는 않는다. 즉 중앙기관에 등록된 은행의 계좌 상에서 돈이 움직이지 않는다. 하루에도 수 천 만건(한국의 경우 하루에 2000만 건 이상으로 알고 있다.)의 거래가 일어나는데 이 거래를 중앙기관이 실시간으로 처리하는 것은 무리이고 효율적이지도 않다. 따라서 한국의 경우 매일 금융결제원과 같은 청산기관이 청산작업을 하여 네팅 처리된 순금액만 주고받도록 한다. 한 동안 움직인 돈이 미수금, 미지급금 등으로 남아있다가 한 번에 결제되는 것이다. 이 때 만약 은행에서 기록한 금액과 청산기관의 금액이 맞지 않는다면 그 이유를 찾기 위한 대장정이 시작될 것이다.. 좋게 말하면 이중 확인을 하는 장점을 가지고 있다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/financial-it-system-metadata/master/img/20231231-money-settlement.png" alt="money settlement" maxWidth="700"/>
</div>

## CM module

모든 이체 방식에 공통적으로 CM이라는 모듈이 있었다. 이 CM은 은행측 내부 인프라에 존재하며 은행과 중앙기관 사이의 미들웨어 역할을 한다. CM이 하는 일은 이체 방식에 따라서 조금씩 달랐다. RFT의 경우 CM이 자체 DB를 가지고 있고, Passcode 발행, Passcode expire 등의 작업을 하고, Passcode 이체 작업의 시작점으로서의 역할까지도 했다. FAST의 경우 인터페이스를 제공하고 중계(Proxy)하는 정도의 역할만 했다. Bakong의 경우 블록체인 기술이 적용되어 있어서 CM에 원장 DB가 있고, 합의 알고리즘을 실행한다.

CM 모듈은 중앙기관에서 제공하는 것이기 때문에, 추상화되어있는 인터페이스를 호출하여 사용할 뿐 내부 구조나 동작을 자세히 설명하는 자료는 거의 없다. 또한 보통 CM과 중앙기관은 인터넷이 아닌 전용선으로 통신을 하기 때문에 보다 보안성이 우수하다.

## 예외 및 오류 처리

대외계 개발에서 예외나 오류를 적절하게 처리하는 건 중요하다. 이러한 처리가 적절히 되지 않았을 때, 내부 데이터와 외부 데이터의 정합성이 깨질 수도 있기 때문이다. 어떻게 처리해야할지 애매한 오류들이 몇 가지 있다.

**처리 방식이 애매한 오류**

1. outgoing: request는 보냈지만 response를 받지 못한 경우.
   > timeout이 발생했을 때, 외부에서 request를 처리했을지 안했을지 확신할 수 없다.
2. incoming: 확인 응답을 보내기 전에 http connection이 끊어져 버리는 경우.
   > 중앙기관이 이런 경우 어떻게 처리하는지를 확인해야한다.
3. outgoing/incoming: 은행 측 어플리케이션에서 internal 에러가 발생한 경우.

   > request를 보내기 전, request 보낸 후 response 받기 전, response 받은 후 어디서 왜 에러가 발생한지 파악이 어렵다.

   > 개발 단계에서 최대한 케이스를 나누어 핸들링 해야한다.

## 거래 식별 id 자리수 문제

16자리의 unique한 숫자 값을 9자리로 변환하면서 unique함을 보장할 수 있는 방법이 있을까? 실제로 FAST Outgoing을 개발하면서 맞딱뜨린 문제이다. 코어뱅킹에서는 16자리 unique한 숫자 값이 어플리케이션으로 전달되었지만 FAST 인터페이스상 9 자리만 입력할 수 있었다.

> FAST의 인터페이스는 ISO20022라는 금융거래 관련 메세지의 국제 표준을 따랐다. 결제 관련 메세지의 스펙인 pain.001.001.05는 PmtInfId라는 태그에 거래를 식별하는 코드를 넣도록 하고 있다. 이 PmfInfId의 최대 길이는 35자리로 제한되어있다. 그런데 FAST 스펙에서는 PmfInfId의 포맷을 "{senderBankCode}/{receiverBankCode}/{uniquePaymentId}" 형식으로 지정해 놓고 있었다. BankCode가 12자리 이기 때문에 "/"까지 해서 35 - 26을 하면 9자리만 남는 상황이었다.

처음에는 어플리케이션에서 별도로 unique number를 채번할까하는 생각도 들었다. 하지만 unique number를 별도로 채번하는 것은 다소 번거롭기도 하고, 9자리를 숫자로 하면 최대 10억까지 밖에 unique한 표현이 안되는 것도 문제였다. 다른 해결 방법은 진수 변환을 하는 것이었다. 진수 변환을 하면 unique number를 직접 채번할 필요도 없고, 코어뱅킹의 unique id 데이터를 잃지 않는다는 이점도 있었다.

16자리를 9자리 이하로 변환하기 위해서 숫자+알파벳 대/소문자를 사용해 62진수로 변환을 하려고 했다. 하지만 FAST의 경우 알파벳 대문자와 숫자만을 허용하는 것을 뒤늦게 발견했다. ~~문서 어디에도 이러한 제한이 있다는 말은 없었다...~~ 결국 코어뱅킹의 unique id에서 unique성을 해치지 않는 값 2자리를 제거하여 14자리로 만든 후 36진수로 변환하는 방법을 적용하여 문제를 해결하였다. (36^9는 약 1.0156e+14로 십진수의 14자리 수 모두를 표현할 수 있다.)

## 느낀점

이런 저런 내용을 많이 적었지만, 대외계 개발을 하면서 가장 중요하다고 느낀 것은 바로 `문서를 읽고 시스템을 파악하는 능력`이다. 그렇지 않으면 분명히 놓치는 부분이 생기고, 협업을 하거나 오류 상황을 핸들링하는 데에도 문제가 생길 수 밖에 없다. 문서를 처음보면 이해가 잘 되지 않는다. 하지만 찬찬히 살펴보면서 이해되는 것은 이해되는 대로, 이해되지 않는 것은 왜 이렇게 하는 건지 퍼즐 맞추듯 파악해나가다보면 어느새 전체 프로세스가 이해가 되기 시작한다. 누군가 대외계 개발을 한다고 하면 무엇보다도 먼저 문서와 자료들을 통해서 시스템을 이해하고, 그 시스템을 설명할 수 있는 수준으로 만들어 놓고 개발을 시작하라고 조언하고 싶다.
